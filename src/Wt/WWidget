// This may look like C code, but it's really -*- C++ -*-
/*
 * Copyright (C) 2008 Emweb bvba, Kessel-Lo, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
#ifndef WWIDGET_H_
#define WWIDGET_H_

#include <Wt/WObject>
#include <Wt/WLength>
#include <Wt/WBorder>
#include <Wt/WSignal>
#include <Wt/WGlobal>

#include <vector>
#include <sstream>

namespace Wt {

class WContainerWidget;
class WCssDecorationStyle;
class WDropEvent;
class WLayout;
class WLayoutItemImpl;
class WLayoutItem;
class WMouseEvent;
class WString;
class WWebWidget;
class DomElement;

/*! \class WWidget Wt/WWidget Wt/WWidget
 *  \brief A %WWidget is the abstract base class for any %Wt widget.
 *
 * The user-interface is organized in a tree structure, in which all
 * nodes are widgets. When a widget is deleted, it is also visually
 * removed from the user-interface and all children are deleted
 * recursively. All widgets, except for the application's root widget
 * have a parent, which is usually a WContainerWidget.
 *
 * %WWidget is abstract and cannot be instantiated. Implementations
 * either from WWebWidget (for basic widgets with a direct HTML
 * counter-part) or WCompositeWidget (for anything else). To add a
 * WWebWidget to a parent WContainerWidget, either specify the parent
 * in the constructor (which is conventionally the last constructor
 * argument), or add the widget to the parent using
 * WContainerWidget::addWidget(WWidget *).
 *
 * A widget provides methods to manage its decorative style. It also
 * provides access to CSS-based layout. Alternatively, you may use
 * layout managers (see WContainerWidget::setLayout()) to manage
 * layout of widgets, in which case you should not use methods that
 * are marked as being involved in CSS-based layout only.
 */
class WT_API WWidget : public WObject
{
public:
  /*! \brief Delete a widget.
   *
   * Deletes a widget and all children (recursively). If the widget is
   * contained in another widget, it is removed first.
   *
   * \sa WContainerWidget::removeWidget()
   */
  virtual ~WWidget();

  /*! \brief Return the parent widget.
   *
   * With few exceptions, the parent is a WContainerWidget, and has
   * been set implicitly when adding the widget to a container using
   * WContainerWidget::addWidget() or by passing a container as a
   * parent to the constructor.
   */
  WWidget *parent() const { return static_cast<WWidget *>(WObject::parent()); }

  /*! \brief Set the widget position scheme.
   *
   * Establishes how the widget must be layed-out relative to its
   * siblings. The default position scheme is Static.
   *
   * This applies to CSS-based layout.
   *
   * \sa Wt::PositionScheme, positionScheme()
   */
  virtual void setPositionScheme(PositionScheme scheme) = 0;

  /*! \brief Returns the widget position scheme.
   *
   * This applies to CSS-based layout.
   *
   * \sa Wt::PositionScheme, setPositionScheme(PositionScheme)
   */
  virtual PositionScheme positionScheme() const = 0;

  /*! \brief Apply offsets to a widget.
   *
   * The argument <i>sides</i> may be a logical concatenation of \link
   * Wt::Left Left\endlink, \link Wt::Right Right\endlink, \link
   * Wt::Top Top\endlink, and \link Wt::Bottom Bottom\endlink.
   *
   * This applies only to widgets that have a position scheme that is
   * \link Wt::Relative Relative\endlink, \link Wt::Absolute
   * Absolute\endlink, or \link Wt::Fixed Fixed\endlink, and has
   * a slightly different meaning for these three cases.
   *
   * For a relatively positioned widget, an offset applies relative to
   * the position the widget would have when layed-out using a \link
   * Wt::Static Static\endlink position scheme. The widget may be
   * shifted to the left or right by specifying an offset to the \link
   * Wt::Left Left\endlink or \link Wt::Right
   * Right\endlink). The widget may be shifted vertically, by
   * specifying an offset for the \link Wt::AlignTop Top\endlink
   * or \link Wt::Bottom Bottom\endlink.
   *
   * For an absolutely positioned widget, an offset specifies a
   * distance of the corresponding side of the widget with respect to
   * the corresponding side of the reference parent widget. Thus,
   * setting all offsets to 0 result in a widget that spans the entire
   * reference widget. The reference parent widget is the first
   * ancestor widget that is a table cell, or a widget with a relative,
   * absolute or fixed position scheme.
   *
   * For an fixed positioned widget, an offset specifies a distance of
   * the corresponding side of the widget with respect to the browser
   * window, regardless of scrolling. Thus, setting all offsets to 0
   * result in a widget that spans the entire browser window.
   *
   * This applies to CSS-based layout.
   *
   * \sa offset(Side) const
   */
  virtual void setOffsets(const WLength& offset, WFlags<Side> sides = All) = 0;

#ifdef WT_TARGET_JAVA
  void setOffsets(int pixels, WFlags<Side> sides = All);
#endif // WT_TARGET_JAVA

  /*! \brief Retrieve the offset of the widget.
   *
   * This applies to CSS-based layout.
   *
   * \sa setOffsets(const WLength&, WFlags<Side>)
   */
  virtual WLength offset(Side side) const = 0;

  /*! \brief Resize the widget.
   *
   * Specify a new size for this widget, by specifying width and height.
   * By default a widget has automatic width and height, see WLength::isAuto().
   *
   * This applies to CSS-based layout.
   *
   * \sa width(), height()
   */
  virtual void resize(const WLength& width, const WLength& height) = 0;

#ifdef WT_TARGET_JAVA
  void resize(int widthPixels, int heightPixels);
#endif // WT_TARGET_JAVA

  /*! \brief Returns the widget width.
   *
   * Return the width set for this widget. This is not a calculated width,
   * based on layout, but the width as specified with
   * resize(const WLength&, const WLength&).
   *
   * This applies to CSS-based layout.
   *
   * \sa resize(const WLength&, const WLength&), height()
   */
  virtual WLength width() const = 0;

  /*! \brief Returns the widget height.
   *
   * Return the height set for this widget. This is not a calculated height,
   * based on layout, but the height as specified previously with
   * resize(const WLength& width, const WLength& height).
   *
   * This applies to CSS-based layout.
   *
   * \sa resize(const WLength&, const WLength&), width()
   */
  virtual WLength height() const = 0;

  /*! \brief Set a minimum size.
   *
   * Specify a minimum size for this widget. When the widget is
   * managed using a layout manager, these sizes are also taken into
   * account.
   *
   * \sa resize(), minimumWidth(), minimumHeight()
   */
  virtual void setMinimumSize(const WLength& width, const WLength& height) = 0;

  /*! \brief Returns the minimum width.
   *
   * Return the minimum width set for this widget with setMinimumSize().
   *
   * \sa setMinimumSize(), minimumHeight()
   */
  virtual WLength minimumWidth() const = 0;

  /*! \brief Returns the minimum height.
   *
   * Return the minmum height set for this widget with setMinimumSize().
   *
   * \sa setMinimumSize(), minimumWidth()
   */
  virtual WLength minimumHeight() const = 0;

  /*! \brief Set a maximum size.
   *
   * Specify a minimum size for this widget.
   *
   * \sa resize(), maximumWidth(), maximumHeight()
   */
  virtual void setMaximumSize(const WLength& width, const WLength& height) = 0;

  /*! \brief Returns the maximum width.
   *
   * Return the maximum width set for this widget with setMaximumSize().
   *
   * \sa setMaximumSize(), maximumHeight()
   */
  virtual WLength maximumWidth() const = 0;

  /*! \brief Returns the maximum height.
   *
   * Return the minmum height set for this widget with setMaximumSize().
   *
   * \sa setMaximumSize(), maximumWidth()
   */
  virtual WLength maximumHeight() const = 0;

  /*! \brief Set the line height for contained text.
   */
  virtual void setLineHeight(const WLength& height) = 0;

  /*! \brief Return the line height for contained text.
   *
   * sa setLineHeight()
   */
  virtual WLength lineHeight() const = 0;

#ifndef WT_TARGET_JAVA
  /*! \brief Specify a side to which the WWidget must float.
   *
   * This only applies to widgets with a \link Wt::Static Static
   * \endlink positionScheme().
   *
   * It specifies if the widget must be positioned on one of the sides
   * of the parent widget, at the current line. A typical use is to
   * position images within text. Valid values for Side or \link
   * Wt::None None \endlink, \link Wt::Left Left \endlink or \link
   * Wt::Right Right \endlink.
   *
   * This applies to CSS-based layout.
   */
  virtual void setFloatSide(Side s) = 0;

  /*! \brief Return the float side.
   *
   * \sa setFloatSide(Side)
   */
  virtual Side floatSide() const = 0;

  /*! \brief Set the sides that should be cleared of floats.
   *
   * This pushes the widget down until it is not surrounded by floats
   * at the <i>sides</i> (which may be a logical OR of \link Wt::Left
   * Left\endlink and \link Wt::Right Right\endlink.
   * 
   * This applies to CSS-based layout.
   *
   * \sa setFloatSide()
   */
  virtual void setClearSides(WFlags<Side> sides) = 0;

  /*! \brief Returns the sides that should remain empty.
   *
   * \sa setClearSides(WFlags<Side>)
   */
  virtual WFlags<Side> clearSides() const = 0;
#endif // WT_TARGET_JAVA

  /*! \brief Set margins around the widget.
   *
   * Setting margin has the effect of adding a distance between the widget
   * and surrounding widgets. The default margin (with an automatic length)
   * is zero.
   *
   * Use any combination of \link Wt::Left Left \endlink,
   * \link Wt::Right Right \endlink,
   * \link Wt::Bottom Bottom \endlink,
   * or \link Wt::Top Top \endlink.
   *
   * This applies to CSS-based layout.
   *
   * \sa margin(Side side);
   */
  virtual void setMargin(const WLength& margin, WFlags<Side> sides = All) = 0;

#ifdef WT_TARGET_JAVA
  virtual void setMargin(int pixels, WFlags<Side> sides = All);
#endif // WT_TARGET_JAVA

  /*! \brief Returns the margin set for that side.
   *
   * This applies to CSS-based layout.
   *
   * \sa setMargin(WLength margin, WFlags<Side> sides);
   */
  virtual WLength margin(Side side) const = 0;

  /*! \brief Set whether the widget must be hidden.
   *
   * Hide or show the widget (including all its descendant widgets).
   * setHidden(false) will show this widget and all child widgets that
   * are not hidden.
   *
   * \sa hide(), show()
   */
  virtual void setHidden(bool hidden) = 0;

  /*! \brief Return whether this widget is set hidden.
   *
   * A widget that is not hidden may still be not visible when one
   * of its ancestor widgets are hidden.
   *
   * \sa setHidden()
   */
  virtual bool isHidden() const = 0;

  /*! \brief Set whether this widget is overlayed on the parent widget.
   *
   * This option only applies to widgets with a \link
   * Wt::Absolute Absolute \endlink or \link Wt::Fixed Fixed
   * \endlink positionScheme().
   *
   * This applies to CSS-based layout.
   *
   * A widget that isPopup() will be rendered on top of the parent widget.
   */
  virtual void setPopup(bool popup) = 0;

  /*! \brief Returns whether this widget is overlayed.
   *
   * This applies to CSS-based layout.
   *
   * \sa setPopup(bool)
   */
  virtual bool isPopup() const = 0;

  /*! \brief Set whether this widget is inline or stacked.
   *
   * This option changes whether this widget must be rendered in-line
   * with sibling widgets wrapping at the right edge of the parent
   * container (like text), or whether this widget must be stacked
   * vertically with sibling widgets. Depending on the widget type,
   * the default value is inline (such as for example for WText, or
   * WPushButton), or stacked (such as for example for WTable).
   *
   * This applies to CSS-based layout.
   */
  virtual void setInline(bool inlined) = 0;

  /*! \brief Returns whether this widget is inline or stacked.
   *
   * \sa setInline(bool)
   */
  virtual bool isInline() const = 0;

  virtual void setDecorationStyle(const WCssDecorationStyle& style) = 0;

  /*! \brief Returns the decoration style of this widget.
   *
   * This groups all decorative aspects of the widget, which do not
   * affect the widget layout (except for the border properties which
   * may behave like extra margin around the widget).
   */
  virtual WCssDecorationStyle& decorationStyle() = 0;

  /*! \brief Sets a style class.
   *
   * The CSS style class works in conjunction with style sheet, and
   * provides a flexible way to provide many widgets the same markup.
   *
   * Setting an empty string removes the style class.
   * 
   * \sa WApplication::styleSheet()
   */
  virtual void setStyleClass(const WT_USTRING& styleClass) = 0;
  void setStyleClass(const char *styleClass);

  /*! \brief Returns the style class.
   *
   * \sa setStyleClass(const WString&)
   */
  virtual WT_USTRING styleClass() const = 0;

  /*! \brief Set the vertical alignment of this (inline) widget.
   *
   * This only applies to inline widgets, and determines how to position
   * itself on the current line, with respect to sibling inline widgets.
   *
   * This applies to CSS-based layout.
   */
  virtual void setVerticalAlignment(AlignmentFlag alignment,
				    const WLength& length = WLength::Auto) = 0;

  /*! \brief Returns the vertical alignment.
   *
   * This applies to CSS-based layout.
   *
   * \sa setVerticalAlignment()
   */
  virtual AlignmentFlag verticalAlignment() const = 0;

  /*! \brief Returns the fixed vertical alignment that was set.
   *
   * This applies to CSS-based layout.
   *
   * \sa setVerticalAlignment()
   */
  virtual WLength verticalAlignmentLength() const = 0;

  /*! \brief Sets a tooltip.
   *
   * The tooltip is displayed when the cursor hovers over the widget.
   */
  virtual void setToolTip(const WString& text) = 0;

  /*! \brief Returns the tooltip text.
   */
  virtual WString toolTip() const = 0;

  /*! \brief Refresh the widget.
   *
   * The refresh method is invoked when the locale is changed using
   * WApplication::setLocale() or when the user hit the refresh button.
   *
   * The widget must actualize its contents in response.
   */
  virtual void refresh() = 0;

  /*! \brief A JavaScript expression that returns the corresponding DOM node.
   *
   * You may want to use this in conjunction with JSlot or
   * WApplication::doJavaScript() in custom JavaScript code.
   */
  std::string jsRef() const;

  /*! \brief Set an attribute value.
   *
   * Associate an extra attribute with this widget, with the given value.
   * This is only useful when processing dom nodes associated with widgets
   * in custom JavaScript code.
   *
   * \sa JSlot, WApplication::doJavaScript()
   */
  virtual void setAttributeValue(const std::string& name,
				 const WT_USTRING& value) = 0;

  /*! \brief Short hand for WString::tr()
   *
   * Create a message with the given key.
   */
  static WString tr(const char *key);

  /*! \brief Load content just before the widget's content is rendered.
   *
   * As soon as a widget is inserted into the widget hierarchy, it is
   * rendered. Visible widgets are rendered immediately, and invisible
   * widgets in the back-ground. This method is called when the widget
   * is directly or indirectly inserted into the widget tree.
   *
   * The default implementation simply propagates the load signal to its
   * children. You may want to override this method to load resource-intensive
   * content only when the widget is loaded into the browser.
   */
  virtual void load() = 0;

  /*! \brief Return if this widget has been loaded.
   *
   * \sa load()
   */
  virtual bool loaded() const = 0;

  /*! \brief Set a mime type to be accepted for dropping.
   *
   * You may specify a style class that is applied to the widget when the
   * specified mimetype hovers on top of it.
   *
   * \sa dropEvent(), WInteractWidget::setDraggable(), stopAcceptDrops()
   */
  virtual void acceptDrops(const std::string& mimeType,
			   const WT_USTRING& hoverStyleClass = WT_USTRING());

  /*! \brief No longer accept a mime type for dropping.
   *
   * \sa acceptDrops()
   */
  virtual void stopAcceptDrops(const std::string& mimeType);

  /*! \brief Set the CSS Id.
   *
   * Sets a custom Id. Note that the Id must be unique across the whole
   * widget tree, can only be set right after construction and cannot
   * be changed.
   *
   * \sa WObject::id()
   */
  virtual void setId(const std::string& id) = 0;

  /*! \brief Stream the (X)HTML representation.
   *
   * Streams the widget as UTF8-encoded (HTML-compatible) XHTML.
   *
   * This may be useful as a debugging tool for the web-savvy, or in
   * other rare situations. Usually, you will not deal directly with
   * HTML, and calling this method on a widget that is rendered may
   * interfere with the library keeping track of changes to the
   * widget.
   */
  virtual void htmlText(std::ostream& out);

  std::string inlineCssStyle();

  std::string createJavaScript(std::stringstream& js,
			       const std::string& insertJS);

  Signal<WWidget *> destroyed;

  /*! \brief Hide this WWidget.
   *
   * \sa setHidden(bool)
   */
  void hide();

  /*! \brief Show this WWidget.
   *
   * \sa setHidden(bool)
   */
  void show();

  virtual DomElement *createSDomElement(WApplication *app) = 0;

protected:
  /*! \brief Create a widget with a given parent.
   *
   * If a parent container is specified, the widget is added to the
   * container, using WContainerWidget::addWidget().
   */
  WWidget(WContainerWidget* parent = 0);

  /*! \brief Handle a drop event.
   *
   * Reimplement this method to handle a drop events for mime types you
   * declared to accept using acceptDrops.
   *
   * The default implementation simply completes the drag and drop operation
   * as if nothing happened.
   *
   * \sa acceptDrops(), WInteractWidget::setDraggable()
   */
  virtual void dropEvent(WDropEvent dropEvent);
  void getDrop(const std::string sourceId, const std::string mimeType,
	       WMouseEvent event);

  virtual void addChild(WWidget *child) = 0;
  virtual void removeChild(WWidget *child) = 0;
  virtual void setHideWithOffsets(bool how = true) = 0;

  virtual void setParent(WWidget *parent);

  virtual bool isVisible() const = 0;
  virtual bool isStubbed() const = 0;
  virtual void render();

  WWidget *adam();

  virtual void setLayout(WLayout *layout);

#ifndef WT_NO_BOOST_INTRUSIVE
  typedef boost::intrusive::list<EventSignalBase> EventSignalList;
#else
  typedef std::list<EventSignalBase *> EventSignalList;
#endif

  void addEventSignal(EventSignalBase& s);
  EventSignalBase *getEventSignal(const char *name);
  EventSignalList& eventSignals() { return eventSignals_; }

  virtual WStatelessSlot *getStateless(Method method);

  void renderOk();
  void askRerender();
  bool needRerender() const { return needRerender_; }

  virtual void getSDomChanges(std::vector<DomElement *>& result,
			      WApplication *app) = 0;
  virtual bool needsToBeRendered() const = 0;

private:
  EventSignalList eventSignals_;
  bool wasHidden_;
  bool needRerender_;

  void undoHideShow();
  virtual WWebWidget *webWidget() = 0;

  virtual WLayoutItemImpl  *createLayoutItemImpl(WLayoutItem *layout);
  virtual WLayout          *layout();

  friend class StdWidgetItemImpl;
  friend class WAbstractArea;
  friend class WContainerWidget;
  friend class WCompositeWidget;
  friend class WebRenderer;
  friend class WLayout;
  friend class WMenuItem;
  friend class WPaintedWidget;
  friend class WScrollArea;
  friend class WSubMenuItem;
  friend class WViewWidget;
  friend class WWebWidget;
  friend class WWidgetItem;
};

}

#endif // WWIDGET_H_
