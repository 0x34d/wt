// This may look like C code, but it's really -*- C++ -*-
/*
 * Copyright (C) 2015 Emweb bvba, Herent, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
#ifndef WJAVASCRIPT_EXPOSABLE_OBJECT_H_
#define WJAVASCRIPT_EXPOSABLE_OBJECT_H_

#include <Wt/WDllDefs.h>

#include <string>
#include <vector>

namespace Wt {

class WJavaScriptObjectStorage;
class WPaintedWidget;

/*! \class WJavaScriptExposableObject Wt/WJavaScriptExposableObject
 *  \brief JavaScript exposable object
 */
class WT_API WJavaScriptExposableObject {
public:
  WJavaScriptExposableObject();
  WJavaScriptExposableObject(const WJavaScriptExposableObject &other);
#ifndef WT_TARGET_JAVA
  WJavaScriptExposableObject &operator=(const WJavaScriptExposableObject &rhs);
#endif

#ifdef WT_TARGET_JAVA
  virtual WJavaScriptExposableObject clone() const = 0;
#endif

  /*! \brief Returns whether this object is JavaScript bound.
   *
   * A JavaScript bound object (as opposed to being mostly
   * a simple value class) has an equivalent representation
   * in JavaScript. Its value can usually only be modified
   * through a WJavaScriptHandle.
   */
  bool isJavaScriptBound() const;

  virtual ~WJavaScriptExposableObject();
  virtual std::string jsValue() const = 0;
  std::string jsRef() const;

protected:
  bool sameBindingAs(const WJavaScriptExposableObject &rhs) const;
  bool sameContextAs(const WJavaScriptExposableObject &rhs) const;
  void assignBinding(const WJavaScriptExposableObject &rhs);
  void assignBinding(const WJavaScriptExposableObject &rhs, const std::string &jsRef);

private:
  template<typename T> friend class WJavaScriptHandle;
  friend class WJavaScriptObjectStorage;

  struct JSInfo {
    JSInfo(WJavaScriptObjectStorage *context, const std::string &jsRef);
    JSInfo(const JSInfo &other);

    JSInfo &operator=(const JSInfo &rhs);

    bool operator==(const JSInfo &rhs) const;

    WJavaScriptObjectStorage *context_;
    std::string jsRef_;
  };

  JSInfo *clientBinding_;
};

}

#endif // WJAVASCRIPT_EXPOSABLE_OBJECT_H_
