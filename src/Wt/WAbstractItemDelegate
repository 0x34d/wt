// This may look like C code, but it's really -*- C++ -*-
/*
 * Copyright (C) 2009 Emweb bvba, Kessel-Lo, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
#ifndef WABSTRACTITEMDELEGATE_H_
#define WABSTRACTITEMDELEGATE_H_

#include <Wt/WObject>
#include <Wt/WFlags>
#include <Wt/WSignal>

#include <boost/any.hpp>

namespace Wt {

/*! \brief Enumeration that specifies an option for rendering a view item.
 *
 * \sa WAbstractItemDelegate::update()
 */
enum ViewItemRenderFlag {
  RenderSelected = 0x1,  //!< Render as selected
  RenderEditing = 0x2    //!< Render in editing mode
};

W_DECLARE_OPERATORS_FOR_FLAGS(ViewItemRenderFlag)

class WAbstractItemModel;
class WWidget;
class WModelIndex;

/*! \class WAbstractItemDelegate Wt/WAbstractItemDelegate Wt/WAbstractItemDelegate
 *  \brief Abstract delegate class for rendering an item in a MVC view.
 *
 * Rendering of an item in a WAbstractItemView is delegated to an
 * implementation of this delegate class. The default implementation
 * used by WAbstractItemView is WItemDelegate. To provide specialized
 * rendering support, you can reimplement this class, and provide a
 * specialized delegate to the view for rendering items.
 *
 * As a delegate is used for rendering multiple items, the class should
 * not keep state about one specific item.
 *
 * An example of a delegate that always renders the text in a
 * line-edit (regardless of whether the view indicates a RenderEditing
 * flag), and saves the modified value back to the (editable) model.
 *
 * \if cpp
 * \code
// A custom delegate that uses an EditItem
class EditItemDelegate : public WAbstractItemDelegate
{
  class EditItem;

public:
  EditItemDelegate(WObject *parent = 0)
    : WAbstractItemDelegate(parent)
  { }

  // Creates or updates an EditItem
  WWidget *update(WWidget *widget, const WModelIndex& index,
		  WFlags<ViewItemRenderFlag> flags)
  {
    EditItem *item;

    if (widget) {
      item = dynamic_cast<EditItem *>(widget);
    } else {
      item = new EditItem(index);
      widget = item;
    }

    boost::any text = index.data(DisplayRole);
    item->edit()->setText(asString(text));

    return widget;
  }

  // Updates the model index of the EditItem
  void updateModelIndex(WWidget *widget, const WModelIndex& index)
  {
    EditItem *item = dynamic_cast<EditItem *>(widget);
    item->setIndex(index);
  }

private:

  // A custom item widget that contains only a WLineEdit
  class EditItem : public WContainerWidget
  {
  public:
    EditItem(const WModelIndex& index)
      : index_(index)
    {
      edit_ = new WLineEdit(this);
      edit_->changed().connect(SLOT(this, EditItem::onEdit));

      setAttributeValue("style", "line-height: 1em;"); // Otherwise the line edit overflows the cell
      setSelectable(true);                             // WAbstractItemView by default disables selection
    }

    // Updates the model index
    void setIndex(const WModelIndex& index) { index_ = index; }

    // Returns the editor
    WLineEdit *edit() const { return edit_; }

  private:
    WLineEdit  *edit_;
    WModelIndex index_;

    // Updates the model with the edited value
    void onEdit() {
      WAbstractItemModel *model
        = const_cast<WAbstractItemModel *>(index_.model());

      model->setData(index_, edit_->text());
    }
  };
};
 * \endcode
 * \endif
 *
 * \sa WTreeView::setItemDelegate(), WTreeView::setItemDelegateForColumn()
 *
 * \ingroup modelview
 */
class WT_API WAbstractItemDelegate : public WObject
{
public:
  /*! \brief Constructor.
   */
  WAbstractItemDelegate(WObject *parent = 0);

  /*! \brief Destructor.
   */
  virtual ~WAbstractItemDelegate();

  /*! \brief Creates or updates a widget that renders an item.
   *
   * The item is specified by its model \p index, which also
   * indicates the model. If an existing widget already renders the
   * item, but needs to be updated, it is passed as the \p widget
   * parameter. You may decide to create a new widget, in which case
   * you are responsible to delete the previous \p widget if it is
   * not reused.
   *
   * When \p widget is \c 0, a new widget needs to be created.
   *
   * The returned widget should be a widget that responds properly to
   * be given a height, width and style class. In practice, that means
   * it cannot have a border or margin, and thus cannot be a
   * WFormWidget since those widgets typically have built-in borders
   * and margins. If you want to return a form widget (for editing the item),
   * you should wrap it in a container widget.
   *
   * The \p flags parameter indicates options for rendering the
   * item.
   */
  virtual WWidget *update(WWidget *widget, const WModelIndex& index,
			  WFlags<ViewItemRenderFlag> flags) = 0;

  /*! \brief Updates the model index of a widget.
   *
   * This method is invoked by the view when due to row/column insertions or
   * removals, the index has shifted.
   *
   * You should reimplement this method only if you are storing the
   * model index in the \p widget, to update the stored model index.
   *
   * The default implementation does nothing.
   */
  virtual void updateModelIndex(WWidget *widget, const WModelIndex& index);

  /*! \brief Returns the current edit state.
   *
   * Because a View may support virtual scrolling in combination with
   * editing, it may happen that the view decides to delete the editor
   * widget while the user is editing. To allow to reconstruct the editor
   * in its original state, the View will therefore ask for the editor
   * to serialize its state in a boost::any.
   *
   * When the view decides to close an editor and save its value back
   * to the model, he will first call editState() and then
   * setModelData().
   *
   * The default implementation assumes a read-only delegate, and
   * returns a boost::any().
   *
   * \sa setEditState(), setModelData()
   */
  virtual boost::any editState(WWidget *widget) const;

  /*! \brief Sets the editor data from the editor state.
   *
   * When the View scrolls back into view an item that was being edited,
   * he will use setEditState() to allow the editor to restore its current
   * editor state.
   *
   * The default implementation assumes a read-only delegate and does
   * nothing.
   *
   * \sa editState()
   */
  virtual void setEditState(WWidget *widget, const boost::any& value) const;

  /*! \brief Saves the edited data to the model.
   *
   * The View will use this method to save the edited value to the model.
   * The \p editState is first fetched from the editor using editState().
   *
   * The default implementation assumes a read-only delegate does
   * nothing.
   */
  virtual void setModelData(const boost::any& editState,
			    WAbstractItemModel *model,
			    const WModelIndex& index) const;

  /*! \brief %Signal which indicates that an editor needs to be closed.
   *
   * The delegate should emit this signal when it decides for itself
   * that it should be closed (e.g. because the user confirmed the
   * edited value or cancelled the editing). The View will then rerender
   * the item if needed.
   *
   * The second boolean argument passed to the signal is a flag which
   * indicates whether the editor feels that the value should be saved or
   * cancelled.
   *
   * \sa WAbstractItemView::closeEditor()
   */
  Signal<WWidget *, bool>& closeEditor() { return closeEditor_; }

  /*! \brief %Signal which indicates that an editor needs to be closed.
   *
   * \sa closeEditor()
   */
  const Signal<WWidget *, bool>& closeEditor() const { return closeEditor_; }

private:
  Signal<WWidget *, bool> closeEditor_;
};

}

#endif // WABSTRACTITEMDELEGATE_H_
